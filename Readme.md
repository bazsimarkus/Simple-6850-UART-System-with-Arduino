# Simple 6850 ACIA System

This circuit provides a simple test environment for a **6850 Asynchronous Communications Interface Adapter (ACIA)** chip. In this specific example, I used an *MC68B50-P* chip, but this software is forward compatible with all of the serial ICs based on the 6850 architecture.

This system serves as an introductory circuit to the world of UARTs, aiming to minimize complexity while keeping the component count low. I created similar circuits using other popular UART/USART chips, like the 8250 and the 8251. Feel free to check them out!

## Breadboard Photo

![Breadboard Photo](https://github.com/bazsimarkus/Simple-6850-UART-System-with-Arduino/raw/master/images/6850_breadboard.jpg)

## Components Needed

- 6850 ACIA chip
- Arduino board (Uno, Nano, both works, the important thing is that it should operate on 5V voltage)
- USB-TTL Serial converter for testing (FTDI will also suffice)
  > The USB-TTL Serial adapter is necessary to test if the circuit is functioning correctly. Refer to "How to use" for details.

## How to Use

1. Connect your Arduino board to the 6850 ACIA chip based on the included schematics.
2. Upload the 6850.ino source code to the Arduino board.
3. Connect the USB-TTL Serial converter to the PC and to the TxD/RxD pins of the 6850
4. Open a serial terminal program (for example, RealTerm), select the COM port of your USB-Serial converter, and set up the terminal to use 9600 baud, 8-bit data, no parity, and 1 stop bit.
5. You should be receiving the string "TESTACIA" once every second.

## How It Works

The Arduino sends 8-bit ASCII characters to the ACIA chip, then the chip converts it to serial data (9600 baud, 8-bit data, no parity, and 1 stop bit). The parameters like the baud rate, parity bit, etc., are initialized by the Arduino at the beginning of the procedure. The text to send is stored in the PROGMEM section of the microcontroller memory, allowing the Arduino to send long messages without any stack problems. No external crystal is needed, as the program utilizes Timer2 of the ATmega328P microcontroller on the Arduino UNO board to generate the clock signal, and achieve the desired standard 9600 Baud rate.

### Register Initialization for Basic 9600 Baud 8N1 Serial Transmission
  - The circuit works like the following: The Arduino sends 8-bit ASCII characters to the ACIA chip, then the chip converts it to serial data. The parameters like the baudrate, parity bit, etc are also initialized by the Arduino in the beginning of the procedure. 
  - The text to send is divided into characters, as the function handles ASCII 8-bit chars.
  - In this circuit the clock pulse is generated by the Arduino itself, so no crystal is needed!
  
  To initialize the UART registers for communication, the Arduino program follows these steps:

1. **Delay for Stability**: To ensure stability after power-up, a short delay is introduced.
2. **Disable ACIA Chip**: Initially, the ACIA chip is disabled by setting the ENABLE pin to LOW.
3. **Set Write Mode**: The R/W line is set to write mode (LOW).
4. **Select Control Register**: The RS line is set to LOW to select the control register.
5. **Deselect Chip for Initial Setup**: The CS2N (Chip Select 2) line is set to HIGH to deselect the chip temporarily for initial setup.
6. **Control Register Configuration**:
   - Clock Divisor Setting: The control register bits CR0 and CR1 are configured to set the clock divisor to 16x.
   - Format Control: Bits D2-D4 are set to specify 8 data bits, no parity, and 1 stop bit (8n1) format.
   - Transmitter Interrupt Control: Bits D5-D6 are disabled to control transmitter interrupts.
   - Receive Interrupt Enable: Bit D7 is disabled to enable receive interrupt.
7. **Select Chip for Normal Operation**: The CS2N line is set to LOW to select the chip for normal operation.
8. **Enable Chip**: The ENABLE pin is set to HIGH to enable the chip after the bus has been properly set.
9. **Disable Chip**: After enabling the chip, it is immediately disabled to prevent transmitting double characters.
10. **End of Initialization**: An indication of the end of initialization is provided by blinking the onboard LED.

This sequence initializes the MC6850 (ACIA) chip for UART communication, configuring the necessary control lines and registers for proper operation.

## Schematic

![Schematic](https://github.com/bazsimarkus/Simple-6850-UART-System-with-Arduino/raw/master/images/6850_sch.png)

## 6850 Properties

The 6850 Asynchronous Communications Interface Adapter (ACIA), alongside counterparts like the 8250 and 8251, emerged as foundational components in serial communication during the mid-1970s. Developed by Motorola Semiconductor, the 6850 ACIA played a pivotal role in facilitating data exchange between microprocessors and peripheral devices, alongside its counterparts from other manufacturers. Renowned for its robust design and versatility, these chips became standard solutions across a wide range of computing applications, including early microprocessor-based systems such as the Motorola 6800 series.

### Pinout of the 6850 ACIA chip (DIP-24)

```plaintext
        ┌───────○───────┐
    Vss │1            24│ CTSN
 RxData │2            23│ DCDN
  RxCLK │3            22│ D0   
  TxCLK │4            21│ D1   
   RTSN │5            20│ D2   
 TxData │6    6850    19│ D3   
   IRQN │7    ACIA    18│ D4   
    CS0 │8            17│ D5   
   CS2N │9            16│ D6   
    CS1 │10           15│ D7   
     RS │11           14│ EN    
    Vcc │12           13│ RWN
        └───────────────┘
```

### Pin Descriptions of the 6850 ACIA chip

| Pin Number | Name       | Type    | Description                     |
|------------|------------|---------|---------------------------------|
| 1          | Vss        | -       | Ground                          |
| 2          | RxData     | In      | Receive Data                    |
| 3          | RxCLK      | In      | Receive Clock                   |
| 4          | TxCLK      | In      | Transmit Clock                  |
| 5          | RTSN       | Out     | Request to Send (Active Low)    |
| 6          | TxData     | Out     | Transmit Data                   |
| 7          | IRQN       | Out     | Interrupt Request (Active Low)  |
| 8          | CS0        | In      | Chip Select 0                   |
| 9          | CS2N       | In      | Chip Select 2 (Active Low)      |
| 10         | CS1        | In      | Chip Select 1                   |
| 11         | RS         | In      | Register Select                 |
| 12         | Vcc        | -       | Positive Supply                 |
| 13         | RWN        | In      | Read/Write (Active Low)         |
| 14         | EN         | In      | Enable (Active Low)             |
| 15         | D7         | In/Out  | Data Bit 7                      |
| 16         | D6         | In/Out  | Data Bit 6                      |
| 17         | D5         | In/Out  | Data Bit 5                      |
| 18         | D4         | In/Out  | Data Bit 4                      |
| 19         | D3         | In/Out  | Data Bit 3                      |
| 20         | D2         | In/Out  | Data Bit 2                      |
| 21         | D1         | In/Out  | Data Bit 1                      |
| 22         | D0         | In/Out  | Data Bit 0                      |
| 23         | DCDN       | In      | Data Carrier Detect (Active Low)|
| 24         | CTSN       | In      | Clear To Send (Active Low)      |

### Register Descriptions for the 6850 ACIA chip

The CPU side of the 6850 ACIA interface involves addressing and interrupt handling. It can be interfaced with either the lower-order byte or the upper-order byte of the processor, with a single register select line (RS) determining the addressed register. While lacking a hardware reset input, the ACIA features an internal power-on-reset circuit and can undergo a secondary reset via software.

On the transmitter side, the ACIA features pins for transmitting clock (TxCLK), transmit data (**TxD**), request-to-send (**RTS***), and clear-to-send (**CTS***). The transmitter clock input synchronizes transmitted signals, while **RTS*** signals readiness to transmit and can be controlled by software. **CTS*** indicates readiness of the external transmitting device.

The receiver side comprises pins for receiving clock (**RxCLK**), receive data (**RxD**), and data carrier detect (**DCD***). The receiver clock aligns with incoming data, while **RxD** receives serial data. **DCD*** indicates the validity of incoming data.

Operationally, the 6850 ACIA includes four user-accessible registers: Transmit Data Register (**TDR**), Receive Data Register (**RDR**), Control Register (**CR**), and Status Register (**SR**). The control register configures operational characteristics, including baud rate, data format, and interrupt settings. The status register provides insights into the status of both the transmitter and receiver portions of the ACIA.

The initUart() function initializes the ACIA by configuring the control register to set the clock divisor, data format, and interrupt control. It sets the clock divisor to 16x, selects a 8 data bits, no parity, 1 stop bit (8n1) format, and disables transmitter and receiver interrupts. Additionally, it configures the ACIA's control lines for proper operation by setting appropriate digital signals.

**The MC6850 Control Register (W) is structured as follows:**
- **Bits 0-1:** Baudrate selection
  - 0: CLK/64
  - 1: CLK/16
  - 2: CLK/1
  - 3: RESET
- **Bits 2-4:** Mode selection (data/stop bits, parity)
  - 0: 7 data bits, even parity, 2 stop bits (7e2)
  - 1: 7 data bits, odd parity, 2 stop bits (7o2)
  - 2: 7 data bits, even parity, 1 stop bit (7e1)
  - 3: 7 data bits, odd parity, 1 stop bit (7o1)
  - 4: 8 data bits, no parity, 2 stop bits (8n2)
  - 5: 8 data bits, no parity, 1 stop bit (8n1)
  - 6: 8 data bits, even parity, 1 stop bit (8e1)
  - 7: 8 data bits, odd parity, 1 stop bit (8o1)
- **Bits 5-6:** Transmit Interrupt/RTS/Break control
  - 0: Output /RTS=low and disable Tx Interrupt
  - 1: Output /RTS=low and enable Tx Interrupt
  - 2: Output /RTS=high and disable Tx Interrupt
  - 3: Output /RTS=low and disable Tx Interrupt, and send a Break
- **Bit 7:** Receive Interrupt (1=Enable on buffer full/buffer overrun)

**The MC6850 Status Register (R) is structured as follows:**
- **Bit 0:** Receive Data (0=No data, 1=Data can be read)
- **Bit 1:** Transmit Data (0=Busy, 1=Ready/Empty, Data can be written)
- **Bit 2:** **/DCD** level
- **Bit 3:** **/CTS** level
- **Bit 4:** Receive Framing Error (1=Error)
- **Bit 5:** Receive Overrun Error (1=Error)
- **Bit 6:** Receive Parity Error (1=Error)
- **Bit 7:** Interrupt Flag (see Control Bits 5-7) (IRQ pin is not connected)

**The MC6850 Data Register (R/W) is structured as follows:**
- **Bits 0-7:** Data
  - Data can be read when Status.Bit0=1, and written when Status.Bit1=1.
  - Rx has a 1-stage fifo, plus 1 shift register (2 stages in total)
  - Tx has a 1-stage fifo, plus 1 shift register (2 stages in total)

## Development

The project was developed using the [Arduino IDE](https://www.arduino.cc/), and testing was conducted with [RealTerm](https://realterm.sourceforge.io/).

Here you can see a screenshot of the result:

![Screenshot](https://raw.githubusercontent.com/bazsimarkus/Simple-6850-UART-System-with-Arduino/master/images/6850_screenshot.png)

## Notes

Check out my other serial test circuit projects, developed concurrently with this circuit!
